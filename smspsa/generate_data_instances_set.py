#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script to generate random network instances.

A network instance consist of a transition matrix, binary adjustment matrix and
objective index.

The transition matrices (i.e., networks) can be generated by two methods: (1)
Filling a matrix with randomly generated uniform values and normalising
the matrix row-wise, (2) Generating a matrix ``Q`` with randomly generated
uniform values and a matrix ``P`` generated according to a directed Erdos-Rényi
graph, combining these matrices by calculating ``alpha*P+(1-alpha)*Q`` and
normalising the resulting matrix row-wise.

The binary adjustment matrix is generated by filling a matrix with randomly
generated ``0`` and ``1`` values. A 50/50 probability is used for generating
``0`` and ``1`` values. To avoid self-loops, the diagonal is filled with
zeroes.

The objective index of the instance is randomly selected between 0 and the
network size.

Per instance, a plot with two histograms that show the edge weight distribution
are provided.

The parameters of the script are explained below.

Parameters
----------
START_SEED_VALUE : int
    The start seed value of the pseudo-random number generator. The first
    network instance is generated with seed ``START_SEED_VALUE``, the second
    with seed ``START_SEED_VALUE+1``, etc.
INSTANCE_SIZE_RANGE : list[int]
    The allowed network size range. The left boundary specifies the minimum
    network size, the right boundary the maximum network size. If you want to
    generate a network of a specific size, simply provide the same left and
    right boundary. For example, if you want to generate a network of size 100,
    provide ``[100, 100]``.
NR_INSTANCES : int
    The number of network instances that will be generated.
NETWORK_TYPE : str
    Specifies the method you want to use to generate the network instances.
    Method (1) above corresponds to "random_uniform", and method (2) above
    corresponds to "networkx".
ALPHA : float
    If method (2) is used to generate the network instances, the matrices ``Q``
    and ``P`` are combined by ``ALPHA*P+(1-ALPHA)*Q``.
PROB : float
    The probability that an edge is created in the Erdos-Rényi graph.
SAVE_OUTPUT : bool
     Whether the output should be saved or not.
DATA_DIRECTORY : str
    The folder, relative to the ROOT_DIRECTORY (automatically determined),
    where the resulting data will be saved if ``SAVE_OUTPUT=True``.
INSTANCE_NAME : str
    The base name of the network instance(s). This name is currently used to
    define ``DATA_FILE_NAME_M_MATRIX``, ``DATA_FILE_NAME_C_MATRIX``,
    ``INSTANCE_PARAMETERS_FILE_NAME`` and ``RUN_PARAMETERS_FILE_NAME``.
DATA_FILE_NAME_M_MATRIX : str
    The base name of the transition matrices. The generated matrices will be
    saved according to this name with a suffix "i" where "i" stands for the
    instance number starting at 0.
DATA_FILE_NAME_C_MATRIX : str
    The base name of the binary adjustment matrices. The generated matrices
    will be saved according to this name with a suffix "i" where "i" stands for
    the instance number starting at 0.
INSTANCE_PARAMETERS_FILE_NAME : str
    The file name of the table that will be saved if ``SAVE_OUTPUT=True`` that
    contains information on the generated network instances. The table contains
    the following columns: ``Instance_name``, ``Random_M``, ``Random_C``,
    ``Seed``, ``Problem_size``, ``Objective_index``. The column ``Instance_name``
    contains the name of each network. The columns ``Random_M`` and ``Random_C``
    specify whether the transition matrices and binary adjustment matrices were
    generated randomly or not, respectively. The column ``Seed`` specifies the
    seed that was used for generating the instance. The column ``Problem_size``
    specifies the network size. The column ``Objective_index`` specifies the
    randomly selected network node that will be optimised.
RUN_PARAMETERS_FILE_NAME : str
    The name of the text file with the script parameters if
    ``SAVE_OUTPUT=True``.
"""

import os
import numpy as np
import pandas as pd
import networkx as nx
import numpy.random as rnd
import matplotlib.pyplot as plt

from pytest import approx

###############################Parameters######################################
START_SEED_VALUE: int = 100
INSTANCE_SIZE_RANGE: list[int] = [5, 10]  # including right-boundary
NR_INSTANCES: int = 5
NETWORK_TYPE: str = "networkx"  # networkx, random_uniform
ALPHA: float = 0.9  # for networkx type of generation
PROB: float = 0.2  # for networkx type of generation

SAVE_OUTPUT: bool = False
ROOT_DIRECTORY: str = os.path.dirname(os.path.dirname(__file__))
DATA_DIRECTORY: str = os.path.join(ROOT_DIRECTORY, "data/example_networks/")
INSTANCE_NAME: str = "example_network"
DATA_FILE_NAME_M_MATRIX: str = f"M_matrix_{INSTANCE_NAME}_"
DATA_FILE_NAME_C_MATRIX: str = f"C_matrix_{INSTANCE_NAME}_"
INSTANCE_PARAMETERS_FILE_NAME: str = f"Instance_Parameters_{INSTANCE_NAME}"
RUN_PARAMETERS_FILE_NAME: str = (
    f"Data_Generation_Run_Parameters_{INSTANCE_NAME}"
)
#############################Save parameters###################################
if __name__ == "__main__":
    if SAVE_OUTPUT:
        with open(
            f"{DATA_DIRECTORY}{RUN_PARAMETERS_FILE_NAME}.txt",
            "w",
            encoding="utf-8",
        ) as f:
            f.write(f"START_SEED_VALUE: {START_SEED_VALUE}\n")
            f.write(f"INSTANCE_SIZE_RANGE: {INSTANCE_SIZE_RANGE}\n")
            f.write(f"NR_INSTANCES: {NR_INSTANCES}\n")
            f.write(f"NETWORK_TYPE: {NETWORK_TYPE}\n")
            f.write(f"ALPHA: {ALPHA}\n")
            f.write(f"PROB: {PROB}\n")
            f.write(f"SAVE_OUTPUT: {SAVE_OUTPUT}\n")
            f.write(f"DATA_DIRECTORY: {DATA_DIRECTORY}\n")
            f.write(f"INSTANCE_NAME: {INSTANCE_NAME}\n")
            f.write(f"DATA_FILE_NAME_M_MATRIX: {DATA_FILE_NAME_M_MATRIX}\n")
            f.write(f"DATA_FILE_NAME_C_MATRIX: {DATA_FILE_NAME_C_MATRIX}\n")
            f.write(
                f"INSTANCE_PARAMETERS_FILE_NAME: {INSTANCE_PARAMETERS_FILE_NAME}\n"
            )
            f.write(f"RUN_PARAMETERS_FILE_NAME: {RUN_PARAMETERS_FILE_NAME}\n")
            f.close()
    #############################Initialization################################
    rng: rnd._generator.Generator
    data_parameters_df = pd.DataFrame(
        columns=[
            "Instance_name",
            "Random_M",
            "Random_C",
            "Seed",
            "Problem_size",
            "Objective_index",
        ]
    )

    #############################Matrix generation#############################
    def generate_transition_matrix_random_uniform(
        size: int, crng: rnd._generator.Generator
    ) -> np.ndarray:
        matrix = crng.uniform(0, 1, (size, size))
        matrix = np.divide(matrix, np.sum(matrix, axis=1)[:, None])
        return matrix

    def generate_transition_matrix_networkx(
        size: int, alpha: float, prob: float, crng: rnd._generator.Generator
    ) -> np.ndarray:
        Q = crng.uniform(0, 1, (size, size))
        P = nx.fast_gnp_random_graph(size, prob, seed=crng, directed=True)
        P = nx.to_numpy_array(P)

        matrix = alpha * P + (1 - alpha) * Q
        matrix = np.divide(matrix, np.sum(matrix, axis=1)[:, None])

        return matrix

    ##############################Generate data################################
    for instance in range(NR_INSTANCES):
        # Generate and save a new instance
        rng = rnd.default_rng(START_SEED_VALUE + instance)

        CURRENT_PROBLEM_SIZE = rng.integers(
            INSTANCE_SIZE_RANGE[0], INSTANCE_SIZE_RANGE[1] + 1
        )
        CURRENT_OBJECTIVE_INDEX = rng.integers(0, CURRENT_PROBLEM_SIZE)
        CURRENT_INSTANCE_NAME = INSTANCE_NAME + "_" + str(instance)

        if NETWORK_TYPE == "random_uniform":
            M = generate_transition_matrix_random_uniform(
                CURRENT_PROBLEM_SIZE, rng
            )
        elif NETWORK_TYPE == "networkx":
            M = generate_transition_matrix_networkx(
                CURRENT_PROBLEM_SIZE, ALPHA, PROB, rng
            )
        else:
            raise Exception(
                "The wrong NETWORK_TYPE was selected. Please use"
                "either 'random_uniform' or 'networkx'."
            )

        C = rng.choice([0, 1], size=M.shape)
        np.fill_diagonal(C, 0)
        new_row = [
            CURRENT_INSTANCE_NAME,
            "Yes",
            "Yes",
            START_SEED_VALUE + instance,
            CURRENT_PROBLEM_SIZE,
            CURRENT_OBJECTIVE_INDEX,
        ]

        # All row sums should be equal to (approx) 1.
        for row in range(np.shape(M)[0]):
            if np.sum(M[row]) != approx(1, abs=1e-12):
                raise Exception(
                    f"The row sum of row {row} is not equal to 1. The "
                    f"row sum is: {np.sum(M[row])}. Error."
                )

        # All M entries are larger or equal to 0 and smaller or equal to 1.
        if not np.all((M >= 0) & (M <= 1)):
            raise Exception(
                "The M contains values lower than 0 or bigger than 1."
                " Error."
            )

        dfM = pd.DataFrame(M)
        dfC = pd.DataFrame(C)
        data_parameters_df.loc[len(data_parameters_df)] = new_row

        if SAVE_OUTPUT:
            dfM.to_csv(
                f"{DATA_DIRECTORY}{DATA_FILE_NAME_M_MATRIX}{str(instance)}.csv",
                index=False,
            )
            dfC.to_csv(
                f"{DATA_DIRECTORY}{DATA_FILE_NAME_C_MATRIX}{str(instance)}.csv",
                index=False,
            )

        # Plot edge weight histogram
        fig, axs = plt.subplots(1, 2, figsize=(10, 5))

        axs[0].hist(M.flatten(), color="darkblue", bins=np.arange(0, 1, 0.01))
        axs[0].set_xlim(0, 1)
        axs[0].set_ylabel("Frequency")
        axs[0].set_xlabel("Edge weight")
        axs[0].set_title("Limits [0,1], binstep 0.01")

        axs[1].hist(M.flatten(), color="darkblue")
        axs[1].set_ylabel("Frequency")
        axs[1].set_xlabel("Edge weight")
        axs[1].set_title("Automatic limits and bins")

        plt.suptitle(
            "Histograms of the edge weights of start transition matrix M"
        )
        plt.show()

    if SAVE_OUTPUT:
        data_parameters_df.to_csv(
            f"{DATA_DIRECTORY}{INSTANCE_PARAMETERS_FILE_NAME}.csv", index=False
        )
